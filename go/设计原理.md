## go 设计原理

### 数据结构

1. 切片

- 变长数组，数据、长度加容量
- 可能分配在堆上，也可能分配在栈上
- 追加扩容、按一定长度翻倍、百分比扩容，拷贝复制

2. 哈希表
- 装载因子：元素数量/桶数量
- 分为正常桶和溢出桶，可以减少扩容的频率，溢出桶和正常桶为连续空间
- 装载因子较大或使用了比较多的溢出桶时，会触发哈希扩容，将旧桶数据分流到新桶。翻倍扩容(创建新bucket，将旧bucket在读时分配给相应新桶1/2，完成后删除旧桶，用于增长)和等量扩容(没有超过负载因子，使用很多溢出桶，创建等量新桶，并迁移到新桶，用于重排)

3. 字符串
- 只读切片，内部需要转p[]byte数组进行扩容

### 并发原语
1. sync.map
- 包含read和dirty段，对read段读不加锁，对dirty段读或写都加锁，查询不到read就查询dirty，按一定miss率统计read穿透率， read为原子变量，dirty为加锁map
- 延迟删除

2. Mutext
- 状态值和信号量
- 包括等待协程计数，饥饿状态，唤醒状态和加锁状态
- 快速加锁，只判断CAS成功
- 慢速加锁，先自旋，然后等待信号量。饥饿模式下，新任务加入队尾，优先处理队列。队列清空后回到正常模式。解决饥饿问题。

2. RWMutext
- 包括Mutext,读写两个信号量队列 和读计数、读等待计数
- 写锁要判断读计数，把当前读计数转为读等待数，并阻塞后续的读操作，累计写信号队列
- 读计数清空后，可以加写锁，逐个处理写信号队列
- 写锁释放后，清口读等待计数，可以继续读
- 读锁前，判断是否被阻塞，阻塞则等待读等待清空，积累读队列
- 不阻塞，则直接读，累加读计数
- 读锁释放，清空读计数

3. channel
- 包括buf段(数据类型和计数)，发送和接收位置，发送和接收等待队列
- 有直接写和写buf两种模式
- 在写入时，如果有等待接收队列，直接写，并唤醒对应携程。如果有buf，则写入buf。如果写满，则阻塞本携程，加入写队列
- 读过程类似，有等待读队列则直接读。否则读buf。如果没有buf，则本携程加入写队列

### 调度过程
1. 协程的实现
- GMP模式，包含全局队列和本地队列，M为系统线程，G为抽象的当前处理器，P为协程处理队列。
- work-steal模式，本地P队列为空时，从全局队列或其他队列拿取
- GMP绑定关系，通常P数量等于M数量，线程阻塞时创建新线程处理，当前G阻塞时，取新的G。系统调用有两种情况raw和非raw,非raw做一层包装，处理系统调用前后的工作，可以立刻返回的是raw。可以加入epoll异步处理的直接解绑P。系统调用阻塞线程时，则挂起当前线程，创建新的处理线程。如fsync，同步读写用会阻塞线程

2. GC过程
- 黑白灰三色标记法
- 灰色为虚拟状态，只要为灰色状态就有机会被处理到，黑色不能直接指向白色，黑色指向白色需要通过额外的灰色路径
- 从标记灰色开始遍历，将黑色节点保留，处理白色节点
- 混合写屏障，包括写屏障和删除屏障，在开始GC标记后开启写屏障，结束GC标记后关闭删除屏障，写屏障确保新增节点为灰色，删除屏障保障标记白色的节点的后续节点为灰色。
- 只有标记前后的开启、关闭屏障需要STW，降低GC对工作协程的影响
- 三色标记相对两色标记，增加了对新增节点的处理。写屏障，在并发处理过程中，增加了对错标记和漏标记的处理。
- GC完成标记后，处理清除内存不用STW
- GC时机，手动GC，定时线程和申请内存(看占比和数量)。如果频繁GC，需要检查是否存在频繁申请堆内存和堆内存剩余量。

