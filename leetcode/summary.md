# 解题思路


## 1.0 算法和数据结构
- 考察的数据结构主要包含：数组、链表、二叉树、图、队列、栈、哈希表等
- 数组
      
     **排序**为考核重点，又以快排、堆排、归并最重要，体现算法的分治、归并思想

        排序算法选择、插入、冒泡等排序体现双指针的用法，快排和堆排做分治，算法复杂度控制在logn

- 链表
    
    以链表为主的题型涉及到节点的查找，插入和删除操作，也常体现递归的用法

- 二叉树

        二叉树的遍历查找较为常见，前序、中序、后序等DFS和BFS查找。二叉树和链表的使用有相近之处，算法考核中较少涉及到双向指针的用法，因此对二叉树和链表的考核难点通常因为其前向指针较难获取，因此常使用递归的方式查找。
        
        二叉搜索树的特征为每项节点左子树<节点<右子树，常用中序遍历解题

        层次遍历的题目比较简单，不做重点。

- 图
    
        图的用法主要体现在DFS和BFS上，考核难点为判断已搜索节点，通常用辅助数组和，遍历用法与二叉树类似，

## 2.0 题型

常见题型覆盖算法如下：

- 双指针用法，同向指针，快慢指针，逆向指针

    - 快慢指针：检测链表回环
    - 逆向指针：接雨水、 回文字符串、三数和
- 滑窗法

    滑窗和双指针大同小异，考核点依然在指针何时偏移

- 哈希表

    常见于要求o(n)复杂度，以空间换时间，hash作为辅助记录已搜索空间

- 栈、ＬＲＵ、链表、二叉树

    考察特定数据结构的用法，链表考核递归，LRU结合优先级队列和栈的用法等，没有固定题型

- 动态规划

    考察重点和难点，解题时先区分是一维还是二维，判定初始状态、递推公式和辅助数组。
    
        可以分为自顶向下和自底向上两种解题思路：
        以斐波拉契数组为例，以循环方式自底向上求解和带备忘录的递归自顶向上求解。
        
    难点在推导递推公式上，下述一维：
    
    - 打家劫舍，当前节点取值取决于上一节点是否取值
    - 打家劫舍II, 环形队列，按位置0是否取值分为两种情况求解
    - 最长递增子序列，当前取值取决于之前所有状态的取值，对大于旧值的在其上+1取最值
    - 零钱兑换，自底向上取步长内的最值
    - 单词拆分，自底向上取所有可拆分的位置推进

    下述二维：
    
    - 最小路径和，m[x][y]为左和上的最小值
    - 最长回文子串，此题用中心扩散更简单
    - 交错字符串，s1横向，s2纵向，判断能否走到右下方
    - 最大正方形，只有该点左侧最值等于上侧最值时，该位置上的边长才在左上+1

- 图搜索

    常见岛屿题，岛屿数量，岛屿最大面积。岛屿周长不用DFS，用扫描。

## 动态规划题型

### 1. 0 斐波拉契数

【自底向上求解】

斐波拉契数fn = fn-1 + fn-2，或者爬楼梯。状态fn只与前一个或前N个状态相关，确定起始状态，用自底向上求解最易。

**变种题型**
- 最小花费爬楼梯

```
fn = min(fn-1, fn-2)+tn
当前楼梯的值取决于fn-1, fn-2，取其最小值
```

- 打家劫舍I

```
偷到每一户取值有偷和不偷两种情况，设不偷为fn，偷为pn，则当前户不偷时，取max(fn-1,pn-1);
当前户偷时，取fn-1+kn;
当前户的最大值为max(fn, pn)
```
**扩展题型** 

```
打家劫舍II

房子围成一圈。确定初始状态。偷位置0不偷末尾，偷末尾不偷位置0，分为两个数组num[1:]和num[:-1]

打家劫舍III

从二叉树上偷窃，不偷相邻节点。需要确定每个节点上能偷和不能偷窃的状态值，该节点不偷窃则为左右子树已知最大值之和，偷则为左右子树不偷的值之和加该点值。该节点取两种情况下的最大值。

对树的遍历使用DFS，用后序遍历，先遍历左右子节点。

用dict保留每个节点的两种取值

打家劫舍IV

```

### 2.0 矩阵求解

【多维矩阵自底向上求解】

- 不同路径

机器人在m*n矩阵，到达右下角的路径数

```
延边沿行走f(x,y)=1,在矩阵内部符合
f(x,y) = f(x-1, y) + f(x, y-1)
```

- 不同路径

已知m*n矩阵中存在障碍，求解路径数
```
在g(x,y)=1的位置f(x,y)数值为0，其余不变
```

- 最小路径和

 用代价举证m*n表示每个位置的耗费，求解路径最小和
```
延边沿行走的f(x,y)为累加值，在矩阵内部符合
f(x,y) = min(f(x-1,y), f(x,y-1))+g(x,y)
```

- 三角矩阵最小路径和
三角形式的路径和求解
```
边沿位置的求解f(x,0)=f(x-1,0)+g(x,0), f(x,-1)=f(x-1,-1)+g(x,-1)
在内部符合f(x,y) = min(f(x-1,y), f(x,y-1))+g(x,y)，和最小路径和解题一样
```

- 最大正方形
```
最大正方形应该符合g(x,y)为连续的1，如果g(x,y)=0,则该位置上f(x,y)=0
如果g(x,y)=1,延边沿f(x,y)=1，
在矩阵内部, 递增值与左上，左，上相关，f(x,y) = min(f(x-1,y-1),f(x-1,y),f(x,y-1))+1
```

### 3.0 求解字符串 

- 最长回文子串(连续)
```
最长回文子串和最长回文子序列(不连续)的解题思路相近，互文作比较

都用上三角矩阵求解，斜列向右上递推求解

最长回文子串连续，用f(x,y)值表示当前状态取值，回文、不是回文；

最长回文子序列不连续，用f(x,y)值表示当前回文最长值；

本题题解如下，
对角线上f(x,y)=True
如果s[x+i] == s[y+i], 则mat[x+i][y+i] = mat[x+i+1][y+i-1]，即左下方值，否则取False
在求解长度最大值y-x+1
如果需要求解字串，则设置tmp记录当前字串

如果需要获取所有的连续子串，则在最大值增加时，建立set记录当前新增字串

对该解法的理解：
对回文连续子串s[i,j]，如果s[i-1]=s[j+1]，则f(x-1,y+1) = f(x,y)状态值，，s[i,j]长度为偶数时，可以看成从空隙开始计算，初始值均为True 
```

斜行遍历形式：
``` python
for j in in range(n):
    x = 0
    y = j
    for i in range(n-j):
        print(mat[x+i][y+i])
        # ! 取左下角位置mat[x+i+1][y+i-1]
```
- 最长回文子序列(不连续)

```
不连续的情况下，其实更好理解，
对于s[x+i] == s[y+i]，则mat[x+i][y+i] = mat[x+i+1][y+i-1]+2，
否则应当为max(mat[x+i][y+i-1], mat[x+i+1][y+i])

对该解法的理解：
对回文子序列s[i,j]，如果当前增加两侧s[i-1]=s[j+1]，则f(x-1,y+1) = f(x,y)+2，否则应该取两侧各只增加一个值时的最大值，对角列上初始值为1，空隙位置上初始值为0，斜向上进行计算
```

**变种题型**

- 单词拆分

利用给定词典，元素可使用无限次，判断是否拆分给定字符串

```
用状态数组记录是否到当前位置可拆分，从位置0开始指针向右偏移步长，记录所有的拆分位置，如果能有一个位置到达终点即可
```    


### 4.0 最长递增子序列

不要求连续

- 判断长度
```
用状态数组记录每个位置结束的最长长度，初始值为1，每个位置的最大长度与之前的每一个值都有关系，即等于f(x) = max(f(x-1), ....) + 1， 如果旧序列的末尾值小于当前值，则可以+1
```
- 等于最大值的递增子序列的个数
```
用额外数组记录所有长度的子序列个数，并更新临时的cnt值及当前的序列长度，返回最后一次求最大序列长度对应的cnt
```

### 5.0 最长公共子序列
子序列不要求连续，是两个字符串重合的长度

```
二维矩阵取(m+1)*(n+1),即从所有不重合的位置开始计数，只在其斜右下角位置做+1
如果g(x-1) = g(y-1), f(x,y) = f(x-1,y-1)+1
否则f(x,y) = max(f(x-1,y),f(x,y-1))

```

### 6.0 二叉树的搜索

- 由1-n数字构成不同的二叉搜索数
```
任意位置上的数数目等于其左数*右数的个数， 0节点和1节点的解法都是1，相同节点数目构成的种数是相等的，即可自底向上求解
```

### 7.0 背包问题

- 完全平方数

```
拆机N的完全平方数个数，
已知任意数可以拆解为完全平方数的和，
先求N以内所有n*n位置的完全平方数，值为1，并记录为候选，和硬币一样
自底向上搜索，以f(x)当前位置加任意值得到的f(x+n) = min(f(x+n),f(x+n)+1)，不断向上递推
```

- 零钱兑换I
给定数组零钱C，和目标数N，求兑换硬币最少个数
```
和上述题解一样，每个硬币代表值为1，从0位置向上递推，仍使用公式
f(x+n) = min(f(x+n),f(x+n)+1)
```

- 零钱兑换II
求零钱兑换额所有种数
```
种数没有顺序，即2+1 == 1+2是一种组合，则人为控制顺序，每次只增加一种硬币，
设置数组f(n+1)表示每个取值的种数，则f(0)位置不用任何硬币的种数为1，向前递推
取硬币值为1时， f(1) = f(0) 。。。 = f(2) = f(3) 。。。f(n),
在此基础上叠加硬币，值为M的硬币 会让f(x+M) += f(M)，增加到达该位置的组合种数

```

### 8.0 灵活的解题思路

- 乘积最大子数组(连续)
```
包含正负，则f(x)数值在f(x-1)之上会跳变，要同时记录最大和最小值
```

### 9.0 总结

    DP的解题思路为初始值+递推公式+取值逻辑，大致分为一维和二维，解题为求目标的值，目标值不同种数，目标取值的所有组合等等，一般为自底向上求解，偶尔也需要自顶向下求解

    简单题如斐波拉契和爬楼梯、打家劫舍等，求解目标值等于过去某组值、和、最大最小值等形式。

    变体为改变递推公式或初始值，如爬楼梯的耗费，打家劫舍II成环等。

    递推公式的设计会遇到连续和不连续两种情况，如设置障碍的机器人路径数，会在该位置中断；最长回文字串和子序列的求解，一个数组为状态值，一个数组为最大取值。

    其变体再增加，如所有的唯一组合，唯一组合的种数等等。如计算所有回文子串和零钱兑换的种数，前者增加辅助的数组或值做记录，后者通常需要变换递推公式。

